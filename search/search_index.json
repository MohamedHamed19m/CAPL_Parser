{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to CAPL Tools Lib","text":"<p>This toolkit helps you parse and edit CAPL files programmatically.</p>"},{"location":"#quick-install","title":"Quick Install","text":"<p><code>pip install capl-tools-lib</code></p>"},{"location":"Usage_Examples/","title":"Usage Examples","text":"<p>This page provides practical examples of how to use <code>capl_tools</code>, specifically focusing on workflows optimized for AI agents and automation.</p>"},{"location":"Usage_Examples/#ai-agent-surgical-workflow","title":"AI Agent Surgical Workflow","text":"<p>One of the primary use cases for <code>capl_tools</code> is allowing an AI agent to modify large CAPL files without needing to read the entire file into its context window. This \"surgical\" approach saves tokens, prevents errors, and ensures precision.</p>"},{"location":"Usage_Examples/#1-discovery-low-token-usage","title":"1. Discovery (Low Token Usage)","text":"<p>The agent first maps the file structure to identify the target elements and their semantic locations.</p> <pre><code>capl_tools scan tests/data/sample.can --toon\n</code></pre>"},{"location":"Usage_Examples/#2-context-extraction","title":"2. Context Extraction","text":"<p>The agent fetches only the specific code block it needs to refactor.</p> <pre><code>capl_tools get tests/data/sample.can TC2_MessageHandling --type TestCase\n</code></pre>"},{"location":"Usage_Examples/#3-surgical-replacement","title":"3. Surgical Replacement","text":"<p>The agent removes the old implementation and inserts the new one directly from a string, eliminating the need for temporary files.</p> <p>Step A: Remove the old element</p> <pre><code>capl_tools remove tests/data/sample.can --type TestCase --name TC2_MessageHandling\n</code></pre> <p>Step B: Insert new implementation directly from string</p> <pre><code>capl_tools insert tests/data/sample.can \\\n    --location after:TC1_ProcessData \\\n    --type TestCase \\\n    --code \"testcase TC2_MessageHandling()\\n{\\n    // Enhanced Logic by AI Agent\\n    write('Starting Advanced Message Handling Test...\\n');\\n    TestStepPass('Initialization', 'Message handlers verified');\\n}\"\n</code></pre>"},{"location":"Usage_Examples/#4-verification","title":"4. Verification","text":"<p>The agent verifies the structure or specific code content to ensure the operation was successful.</p> <pre><code>capl_tools stats tests/data/sample.can\n# OR\ncapl_tools get tests/data/sample.can TC2_MessageHandling --type TestCase\n</code></pre>"},{"location":"Usage_Examples/#benefits-of-this-workflow","title":"Benefits of this Workflow","text":"<ul> <li>Context Efficiency: No need to process thousands of lines of code.</li> <li>Precision: Semantic anchoring (e.g., <code>after:FunctionName</code>) ensures code is placed correctly even if line numbers change.</li> <li>Speed: Atomic operations using the <code>--code</code> flag are faster than full-file rewrites.</li> <li>Reliability: Minimal disk I/O and no temporary file management.</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>The <code>capl_tools</code> command-line interface allows you to scan and modify CAPL files quickly.</p>"},{"location":"reference/cli/#capl_tools","title":"capl_tools","text":"<p>A powerful CLI for parsing and manipulating CAPL files.</p>"},{"location":"reference/cli/#usage","title":"Usage","text":"<p><code>capl_tools [OPTIONS] COMMAND [ARGS]...</code></p>"},{"location":"reference/cli/#arguments","title":"Arguments","text":"<p>No arguments available</p>"},{"location":"reference/cli/#options","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#commands","title":"Commands","text":"Name Description <code>scan</code> List the logical structure of a CAPL file... <code>stats</code> Get a highly compressed inventory of the... <code>remove</code> Remove a specific element by its type and... <code>get</code> Fetch the raw code of a specific element. <code>insert</code> Insert code at specified location using..."},{"location":"reference/cli/#sub-commands","title":"Sub Commands","text":""},{"location":"reference/cli/#capl_tools-scan","title":"<code>capl_tools scan</code>","text":"<p>List the logical structure of a CAPL file (Names, Signatures, and Types).</p>"},{"location":"reference/cli/#usage_1","title":"Usage","text":"<p><code>capl_tools scan [OPTIONS] PATH</code></p>"},{"location":"reference/cli/#arguments_1","title":"Arguments","text":"Name Description Required <code>PATH</code> Path to the .can file Yes"},{"location":"reference/cli/#options_1","title":"Options","text":"Name Description Required Default <code>--toon</code> Output structure in TOON No - <code>--full</code> Include physical line numbers in the output No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#capl_tools-stats","title":"<code>capl_tools stats</code>","text":"<p>Get a highly compressed inventory of the CAPL file content.</p>"},{"location":"reference/cli/#usage_2","title":"Usage","text":"<p><code>capl_tools stats [OPTIONS] PATH</code></p>"},{"location":"reference/cli/#arguments_2","title":"Arguments","text":"Name Description Required <code>PATH</code> Path to the .can file Yes"},{"location":"reference/cli/#options_2","title":"Options","text":"Name Description Required Default <code>-m, --machine</code> Single-line output (e.g., TestCase:15 Function:3) No <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#capl_tools-remove","title":"<code>capl_tools remove</code>","text":"<p>Remove a specific element by its type and name.</p>"},{"location":"reference/cli/#usage_3","title":"Usage","text":"<p><code>capl_tools remove [OPTIONS] PATH</code></p>"},{"location":"reference/cli/#arguments_3","title":"Arguments","text":"Name Description Required <code>PATH</code> Path to the .can file Yes"},{"location":"reference/cli/#options_3","title":"Options","text":"Name Description Required Default <code>-t, --type [TestCase|Function|Handler|TestFunction|CaplInclude|CaplVariable|TestGroup]</code> Type of element to remove Yes - <code>-n, --name TEXT</code> Name of the element to remove Yes - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#capl_tools-get","title":"<code>capl_tools get</code>","text":"<p>Fetch the raw code of a specific element.</p>"},{"location":"reference/cli/#usage_4","title":"Usage","text":"<p><code>capl_tools get [OPTIONS] PATH NAME</code></p>"},{"location":"reference/cli/#arguments_4","title":"Arguments","text":"Name Description Required <code>PATH</code> Path to the .can file Yes <code>NAME</code> Name of the element to fetch Yes"},{"location":"reference/cli/#options_4","title":"Options","text":"Name Description Required Default <code>-t, --type TEXT</code> Type of element (e.g. TestCase, Function, Handler) Yes - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#capl_tools-insert","title":"<code>capl_tools insert</code>","text":"<p>Insert code at specified location using semantic anchoring.</p>"},{"location":"reference/cli/#usage_5","title":"Usage","text":"<p><code>capl_tools insert [OPTIONS] PATH</code></p>"},{"location":"reference/cli/#arguments_5","title":"Arguments","text":"Name Description Required <code>PATH</code> Path to the .can file Yes"},{"location":"reference/cli/#options_5","title":"Options","text":"Name Description Required Default <code>-l, --location TEXT</code> Location: 'after:', 'section:', or 'line:' Yes - <code>-t, --type [TestCase|Function|Handler|TestFunction|CaplInclude|CaplVariable|TestGroup]</code> Type of element being inserted No - <code>-s, --source PATH</code> Path to code snippet (omit to read from stdin) No - <code>-c, --code TEXT</code> Code string to insert directly No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/processor/","title":"CaplProcessor","text":""},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor","title":"<code>capl_tools_lib.processor.CaplProcessor</code>","text":"<p>High-level facade for processing CAPL files. Coordinates FileManager, Scanner, and Editor to perform complex operations. Implements the Facade pattern to simplify interactions with the CAPL toolchain.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>class CaplProcessor:\n    \"\"\"\n    High-level facade for processing CAPL files.\n    Coordinates FileManager, Scanner, and Editor to perform complex operations.\n    Implements the Facade pattern to simplify interactions with the CAPL toolchain.\n    \"\"\"\n\n    def __init__(self, file_path: Path):\n        self.file_path = file_path\n        self.file_manager = CaplFileManager(file_path)\n        self.editor = CaplEditor(self.file_manager)\n        self.scanner = CaplScanner(self.file_manager)\n        self._elements: Optional[List[CAPLElement]] = None\n        self._dirty = False # Tracks if file has been modified since last scan\n\n    def scan(self, force_refresh: bool = False) -&gt; List[CAPLElement]:\n        \"\"\"\n        Scans the file for elements. \n        Automatically syncs scanner with editor changes if needed.\n        \"\"\"\n        if self._dirty:\n            # Sync FileManager with Editor content so Scanner sees changes\n            # Note: Scanner reads file_manager.lines\n            self.file_manager.lines = list(self.editor.get_lines())\n            force_refresh = True\n            self._dirty = False\n\n        if self._elements is None or force_refresh:\n            self._elements = self.scanner.scan_all()\n\n        return self._elements\n\n    def get_stats(self) -&gt; Dict[str, int]:\n        \"\"\"Returns a count of each element type.\"\"\"\n        elements = self.scan()\n        from collections import Counter\n        return dict(Counter(el.__class__.__name__ for el in elements))\n\n    def remove_test_group(self, group_name: str) -&gt; int:\n        \"\"\"\n        Removes all test cases belonging to the specified group.\n        Returns the number of test cases removed.\n        \"\"\"\n        # Ensure we have fresh elements (will sync if dirty)\n        elements = self.scan()\n\n        to_remove = [\n            el for el in elements \n            if isinstance(el, TestCase) and el.group_name == group_name\n        ]\n\n        if not to_remove:\n            return 0\n\n        logger.info(f\"Processor removing {len(to_remove)} test cases from group '{group_name}'\")\n\n        # Use the editor to remove them\n        # Note: We must remove in reverse order of line numbers to avoid index shifts\n        # But your editor.remove_elements might handle this? \n        # If not, sort here:\n        to_remove.sort(key=lambda x: x.start_line, reverse=True)\n        self.editor.remove_elements(to_remove)\n\n        # Mark as dirty so next scan re-reads from editor\n        self._dirty = True\n        self._elements = None \n\n        return len(to_remove)\n\n    def remove_element(self, element_type: str, name: str) -&gt; int:\n        \"\"\"\n        Removes elements matching the type and name.\n        Returns the number of elements removed.\n        \"\"\"\n        # Ensure we have fresh elements (will sync if dirty)\n        elements = self.scan()\n\n        to_remove = [\n            el for el in elements \n            if el.__class__.__name__ == element_type and el.name == name\n        ]\n\n        if not to_remove:\n            return 0\n\n        logger.info(f\"Processor removing {len(to_remove)} elements of type '{element_type}' with name '{name}'\")\n\n        # Use the editor to remove them\n        # Note: We must remove in reverse order of line numbers to avoid index shifts\n        # But your editor.remove_elements might handle this? \n        # If not, sort here:\n        to_remove.sort(key=lambda x: x.start_line, reverse=True)\n        self.editor.remove_elements(to_remove)\n\n        # Mark as dirty so next scan re-reads from editor\n        self._dirty = True\n        self._elements = None \n\n        return len(to_remove)\n\n    def get_element_code(self, element_type: str, name: str) -&gt; Optional[str]:\n        \"\"\"\n        Returns the raw code of the specified element as a string.\n        \"\"\"\n        elements = self.scan()\n        target = next((el for el in elements if el.__class__.__name__ == element_type and el.name == name), None)\n\n        if not target:\n            return None\n\n        lines = self.editor.get_lines()\n        # target.start_line and target.end_line are 0-indexed inclusive\n        element_lines = lines[target.start_line : target.end_line + 1]\n        return \"\".join(element_lines)\n\n    def insert(\n        self, \n        location: str, \n        element_type: Optional[str] = None, \n        source: Optional[Path] = None, \n        code_string: Optional[str] = None\n    ) -&gt; bool:\n        \"\"\"\n        Inserts code based on a semantic location anchor.\n\n        Args:\n            location: Semantic anchor (e.g., \"after:MyFunction\", \"line:42\")\n            element_type: Type of element being inserted (TestCase, Function, etc.)\n            source: Path to file containing code (optional)\n            code_string: Code as string (optional)\n\n        Returns:\n            bool: True if insertion was successful.\n\n        Raises:\n            ValueError: If neither or both source/code_string are provided, or location invalid.\n        \"\"\"\n        # Validate inputs\n        if source is None and code_string is None:\n            raise ValueError(\"Must provide either 'source' or 'code_string'\")\n\n        if source is not None and code_string is not None:\n            raise ValueError(\"Cannot provide both 'source' and 'code_string'\")\n\n        # Get code content\n        code = \"\"\n        if source:\n            if not source.exists():\n                raise ValueError(f\"Source file {source} not found.\")\n            # Use file_manager or standard read? FileManager handles encoding usually.\n            # But file_manager reads the MAIN file. Here we read a snippet.\n            # Using standard read_text is fine, or better, use same encoding as FileManager (cp1252)\n            try:\n                code = source.read_text(encoding='cp1252')\n            except UnicodeDecodeError:\n                # Fallback to utf-8 if cp1252 fails, or just let it fail?\n                # Usually snippets might be utf-8. Let's try utf-8 as default for snippets since they are likely generated or separate.\n                # Actually, CAPL is cp1252. Stick to common.\n                code = source.read_text(encoding='utf-8', errors='replace')\n        else:\n            code = code_string\n\n        elements = self.scan()\n        target_line = -1\n\n        if location.startswith(\"after:\"):\n            name = location.split(\":\", 1)[1]\n            target = next((el for el in elements if el.name == name), None)\n            if target:\n                target_line = target.end_line + 1\n            else:\n                raise ValueError(f\"Anchor element '{name}' not found.\")\n\n        elif location.startswith(\"line:\"):\n            target_line = int(location.split(\":\", 1)[1])\n\n        elif location.startswith(\"section:\"):\n            section_name = location.split(\":\", 1)[1]\n            from capl_tools_lib.elements import CaplInclude, CaplVariable, TestCase\n\n            if section_name.lower() == \"includes\":\n                target = next((el for el in elements if isinstance(el, CaplInclude)), None)\n                target_line = target.end_line + 1 if target else 0\n            elif section_name.lower() == \"variables\":\n                target = next((el for el in elements if isinstance(el, CaplVariable)), None)\n                target_line = target.end_line + 1 if target else 0\n            else:\n                # Assume section_name is a Test Group name\n                group_elements = [el for el in elements if isinstance(el, TestCase) and el.group_name == section_name]\n                if group_elements:\n                    # Insert after the last test case of the group\n                    target_line = group_elements[-1].end_line + 1\n                else:\n                    raise ValueError(f\"Section or Group '{section_name}' not found.\")\n\n        if target_line == -1:\n            raise ValueError(f\"Could not resolve location: {location}\")\n\n        # Basic validation if element_type is provided (could be expanded)\n        if element_type == \"TestCase\" and \"testcase\" not in code.lower():\n            logger.warning(\"Inserting a TestCase but 'testcase' keyword not found in code.\")\n\n        # Ensure code ends with a newline and has proper padding\n        if not code.endswith(\"\\n\"):\n            code += \"\\n\"\n\n        # Split into lines keeping the newlines\n        lines_to_insert = code.splitlines(keepends=True)\n\n        # Add a leading newline for spacing if inserting in middle of file\n        if target_line &gt; 0:\n            lines_to_insert.insert(0, \"\\n\")\n\n        self.editor.insert_lines(target_line, lines_to_insert)\n        self._dirty = True\n        self._elements = None\n        return True\n\n    def save(self, output_path: Optional[Path] = None, backup: bool = True) -&gt; None:        \n        \"\"\"Saves changes to disk.\"\"\"\n        target = output_path if output_path else self.file_manager.file_path\n        lines = self.editor.get_lines()\n        self.file_manager.save_file(target, lines, backup=backup)\n\n    def reload(self) -&gt; None:\n        \"\"\"Reloads the file from disk, discarding unsaved changes.\"\"\"\n        self.editor.reset()\n        self.file_manager._read_file() # Re-read from disk\n        self._dirty = False\n        self._elements = None\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.get_element_code","title":"<code>get_element_code(element_type, name)</code>","text":"<p>Returns the raw code of the specified element as a string.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def get_element_code(self, element_type: str, name: str) -&gt; Optional[str]:\n    \"\"\"\n    Returns the raw code of the specified element as a string.\n    \"\"\"\n    elements = self.scan()\n    target = next((el for el in elements if el.__class__.__name__ == element_type and el.name == name), None)\n\n    if not target:\n        return None\n\n    lines = self.editor.get_lines()\n    # target.start_line and target.end_line are 0-indexed inclusive\n    element_lines = lines[target.start_line : target.end_line + 1]\n    return \"\".join(element_lines)\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.get_stats","title":"<code>get_stats()</code>","text":"<p>Returns a count of each element type.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def get_stats(self) -&gt; Dict[str, int]:\n    \"\"\"Returns a count of each element type.\"\"\"\n    elements = self.scan()\n    from collections import Counter\n    return dict(Counter(el.__class__.__name__ for el in elements))\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.insert","title":"<code>insert(location, element_type=None, source=None, code_string=None)</code>","text":"<p>Inserts code based on a semantic location anchor.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Semantic anchor (e.g., \"after:MyFunction\", \"line:42\")</p> required <code>element_type</code> <code>Optional[str]</code> <p>Type of element being inserted (TestCase, Function, etc.)</p> <code>None</code> <code>source</code> <code>Optional[Path]</code> <p>Path to file containing code (optional)</p> <code>None</code> <code>code_string</code> <code>Optional[str]</code> <p>Code as string (optional)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if insertion was successful.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither or both source/code_string are provided, or location invalid.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def insert(\n    self, \n    location: str, \n    element_type: Optional[str] = None, \n    source: Optional[Path] = None, \n    code_string: Optional[str] = None\n) -&gt; bool:\n    \"\"\"\n    Inserts code based on a semantic location anchor.\n\n    Args:\n        location: Semantic anchor (e.g., \"after:MyFunction\", \"line:42\")\n        element_type: Type of element being inserted (TestCase, Function, etc.)\n        source: Path to file containing code (optional)\n        code_string: Code as string (optional)\n\n    Returns:\n        bool: True if insertion was successful.\n\n    Raises:\n        ValueError: If neither or both source/code_string are provided, or location invalid.\n    \"\"\"\n    # Validate inputs\n    if source is None and code_string is None:\n        raise ValueError(\"Must provide either 'source' or 'code_string'\")\n\n    if source is not None and code_string is not None:\n        raise ValueError(\"Cannot provide both 'source' and 'code_string'\")\n\n    # Get code content\n    code = \"\"\n    if source:\n        if not source.exists():\n            raise ValueError(f\"Source file {source} not found.\")\n        # Use file_manager or standard read? FileManager handles encoding usually.\n        # But file_manager reads the MAIN file. Here we read a snippet.\n        # Using standard read_text is fine, or better, use same encoding as FileManager (cp1252)\n        try:\n            code = source.read_text(encoding='cp1252')\n        except UnicodeDecodeError:\n            # Fallback to utf-8 if cp1252 fails, or just let it fail?\n            # Usually snippets might be utf-8. Let's try utf-8 as default for snippets since they are likely generated or separate.\n            # Actually, CAPL is cp1252. Stick to common.\n            code = source.read_text(encoding='utf-8', errors='replace')\n    else:\n        code = code_string\n\n    elements = self.scan()\n    target_line = -1\n\n    if location.startswith(\"after:\"):\n        name = location.split(\":\", 1)[1]\n        target = next((el for el in elements if el.name == name), None)\n        if target:\n            target_line = target.end_line + 1\n        else:\n            raise ValueError(f\"Anchor element '{name}' not found.\")\n\n    elif location.startswith(\"line:\"):\n        target_line = int(location.split(\":\", 1)[1])\n\n    elif location.startswith(\"section:\"):\n        section_name = location.split(\":\", 1)[1]\n        from capl_tools_lib.elements import CaplInclude, CaplVariable, TestCase\n\n        if section_name.lower() == \"includes\":\n            target = next((el for el in elements if isinstance(el, CaplInclude)), None)\n            target_line = target.end_line + 1 if target else 0\n        elif section_name.lower() == \"variables\":\n            target = next((el for el in elements if isinstance(el, CaplVariable)), None)\n            target_line = target.end_line + 1 if target else 0\n        else:\n            # Assume section_name is a Test Group name\n            group_elements = [el for el in elements if isinstance(el, TestCase) and el.group_name == section_name]\n            if group_elements:\n                # Insert after the last test case of the group\n                target_line = group_elements[-1].end_line + 1\n            else:\n                raise ValueError(f\"Section or Group '{section_name}' not found.\")\n\n    if target_line == -1:\n        raise ValueError(f\"Could not resolve location: {location}\")\n\n    # Basic validation if element_type is provided (could be expanded)\n    if element_type == \"TestCase\" and \"testcase\" not in code.lower():\n        logger.warning(\"Inserting a TestCase but 'testcase' keyword not found in code.\")\n\n    # Ensure code ends with a newline and has proper padding\n    if not code.endswith(\"\\n\"):\n        code += \"\\n\"\n\n    # Split into lines keeping the newlines\n    lines_to_insert = code.splitlines(keepends=True)\n\n    # Add a leading newline for spacing if inserting in middle of file\n    if target_line &gt; 0:\n        lines_to_insert.insert(0, \"\\n\")\n\n    self.editor.insert_lines(target_line, lines_to_insert)\n    self._dirty = True\n    self._elements = None\n    return True\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.reload","title":"<code>reload()</code>","text":"<p>Reloads the file from disk, discarding unsaved changes.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reloads the file from disk, discarding unsaved changes.\"\"\"\n    self.editor.reset()\n    self.file_manager._read_file() # Re-read from disk\n    self._dirty = False\n    self._elements = None\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.remove_element","title":"<code>remove_element(element_type, name)</code>","text":"<p>Removes elements matching the type and name. Returns the number of elements removed.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def remove_element(self, element_type: str, name: str) -&gt; int:\n    \"\"\"\n    Removes elements matching the type and name.\n    Returns the number of elements removed.\n    \"\"\"\n    # Ensure we have fresh elements (will sync if dirty)\n    elements = self.scan()\n\n    to_remove = [\n        el for el in elements \n        if el.__class__.__name__ == element_type and el.name == name\n    ]\n\n    if not to_remove:\n        return 0\n\n    logger.info(f\"Processor removing {len(to_remove)} elements of type '{element_type}' with name '{name}'\")\n\n    # Use the editor to remove them\n    # Note: We must remove in reverse order of line numbers to avoid index shifts\n    # But your editor.remove_elements might handle this? \n    # If not, sort here:\n    to_remove.sort(key=lambda x: x.start_line, reverse=True)\n    self.editor.remove_elements(to_remove)\n\n    # Mark as dirty so next scan re-reads from editor\n    self._dirty = True\n    self._elements = None \n\n    return len(to_remove)\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.remove_test_group","title":"<code>remove_test_group(group_name)</code>","text":"<p>Removes all test cases belonging to the specified group. Returns the number of test cases removed.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def remove_test_group(self, group_name: str) -&gt; int:\n    \"\"\"\n    Removes all test cases belonging to the specified group.\n    Returns the number of test cases removed.\n    \"\"\"\n    # Ensure we have fresh elements (will sync if dirty)\n    elements = self.scan()\n\n    to_remove = [\n        el for el in elements \n        if isinstance(el, TestCase) and el.group_name == group_name\n    ]\n\n    if not to_remove:\n        return 0\n\n    logger.info(f\"Processor removing {len(to_remove)} test cases from group '{group_name}'\")\n\n    # Use the editor to remove them\n    # Note: We must remove in reverse order of line numbers to avoid index shifts\n    # But your editor.remove_elements might handle this? \n    # If not, sort here:\n    to_remove.sort(key=lambda x: x.start_line, reverse=True)\n    self.editor.remove_elements(to_remove)\n\n    # Mark as dirty so next scan re-reads from editor\n    self._dirty = True\n    self._elements = None \n\n    return len(to_remove)\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.save","title":"<code>save(output_path=None, backup=True)</code>","text":"<p>Saves changes to disk.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def save(self, output_path: Optional[Path] = None, backup: bool = True) -&gt; None:        \n    \"\"\"Saves changes to disk.\"\"\"\n    target = output_path if output_path else self.file_manager.file_path\n    lines = self.editor.get_lines()\n    self.file_manager.save_file(target, lines, backup=backup)\n</code></pre>"},{"location":"reference/processor/#capl_tools_lib.processor.CaplProcessor.scan","title":"<code>scan(force_refresh=False)</code>","text":"<p>Scans the file for elements.  Automatically syncs scanner with editor changes if needed.</p> Source code in <code>src/capl_tools_lib/processor.py</code> <pre><code>def scan(self, force_refresh: bool = False) -&gt; List[CAPLElement]:\n    \"\"\"\n    Scans the file for elements. \n    Automatically syncs scanner with editor changes if needed.\n    \"\"\"\n    if self._dirty:\n        # Sync FileManager with Editor content so Scanner sees changes\n        # Note: Scanner reads file_manager.lines\n        self.file_manager.lines = list(self.editor.get_lines())\n        force_refresh = True\n        self._dirty = False\n\n    if self._elements is None or force_refresh:\n        self._elements = self.scanner.scan_all()\n\n    return self._elements\n</code></pre>"}]}